Блочная компоновка
До сих пор мы сосредоточились на компоновке текста, но веб-страницы на самом деле состоят из более крупных блоков, таких как заголовки, абзацы и меню, которые располагаются вертикально друг за другом. Нам нужно добавить поддержку такого типа макета в наш браузер, и способ, которым мы собираемся это сделать, подразумевает расширение дерева макета, которое мы уже построили.

Основная идея заключается в том, что у нас будет целое дерево BlockLayout объектов (с DocumentLayout в корне). Некоторые из них будут представлять собой листовые блоки, содержащие текст, и они будут располагать свое содержимое так, как мы уже реализовали (горизонтально). Но также будут новые, промежуточные BlockLayouts с BlockLayout дочерними элементами, и они будут располагать своих дочерних элементов вертикально.

![block layout scheme](https://browser.engineering/im/layout-tree-2.gif)

Вычисление позиции блочного элемента при Layout

```
BlockLayout/__init__
    <!-- инзачальный "x" перенимает "x" родителя, потомучто блочный элемент начинается с новой строки и "x" никуда не двигается -->
    self.x = self.parent.x
    <!-- изначальная длина перенимает длину родителя, так как родитель определяет внутри себя длину взависимости от контента и она будет конечной -->
    self.width = self.parent.width

BlockLayout/layout()
        # Вертикальное положение макета объекта зависит от того есть ли у элемента сиблинг
        # чтобы выровнять по нему, тобишь - y позиция предыдущего сиблинга заполнила пространство его высотой: y - начало + height
        if self.previous:
            # self.y = начало пред блока + его высота
            self.y = self.previous.y + self.previous.height
        # если нет сиблинга берем "y" родителя как начало
        else:
            self.y = self.parent.y

```
![Блок-схема, показывающая, как ширина вычисляется сверху вниз, от родительского элемента к дочернему, а высота вычисляется снизу вверх, от дочернего элемента к родительскому.](https://browser.engineering/im/layout-order.png)

